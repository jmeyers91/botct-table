{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["stateKey","initialState","localStorage","getItem","players","showTable","getTableCircle","canvas","width","height","x","y","radius","Math","min","getPlayerPositions","tableCircle","playerCount","length","map","player","i","cos","PI","sin","getDistance","a","b","dx","dy","sqrt","JSON","parse","App","useState","setShowTable","setPlayers","setCanvas","canvasContext","useMemo","getContext","handleAddPlayer","useCallback","id","uuid","name","dead","handleRemovePlayer","playerId","filter","handlePlayerNameChange","toggleShowTable","handleCanvasClick","event","playerPositions","mousePosition","getBoundingClientRect","left","top","scaleX","scaleY","clientX","clientY","getCanvasMousePosition","playerPositionsWithDistance","playerPosition","distance","sort","nearest","playerToKill","handleExportTableClick","now","Date","filename","getHours","getMinutes","getSeconds","fileName","link","document","createElement","setAttribute","toDataURL","replace","click","downloadCanvas","useEffect","context","clearRect","fillStyle","fillRect","beginPath","arc","stroke","font","textAlign","fillText","moveTo","lineTo","renderTable","timeout","setTimeout","setItem","stringify","clearTimeout","className","ref","onClick","key","value","onChange","currentTarget","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.b6f3d22d.chunk.js","sourcesContent":["import React, { useState, useCallback, useEffect, useMemo } from \"react\";\nimport { v4 as uuid } from \"uuid\";\nimport \"./App.css\";\n\nconst stateVersion = 1;\nconst stateKey = `botct_state_${stateVersion}`;\nlet initialState = localStorage.getItem(stateKey) || {\n  players: [],\n  showTable: false,\n};\n\nif (initialState && typeof initialState === \"string\") {\n  initialState = JSON.parse(initialState);\n}\n\nfunction App() {\n  const [showTable, setShowTable] = useState(initialState.showTable);\n  const [players, setPlayers] = useState(initialState.players);\n  const [canvas, setCanvas] = useState(null);\n  const canvasContext = useMemo(() => canvas && canvas.getContext(\"2d\"), [\n    canvas,\n  ]);\n\n  const handleAddPlayer = useCallback(() => {\n    setPlayers((players) => [\n      ...players,\n      {\n        id: uuid(),\n        name: \"\",\n        dead: false,\n      },\n    ]);\n  }, []);\n\n  const handleRemovePlayer = useCallback((playerId) => {\n    setPlayers((players) => players.filter((player) => player.id !== playerId));\n  }, []);\n\n  const handlePlayerNameChange = useCallback((playerId, name) => {\n    setPlayers((players) =>\n      players.map((player) =>\n        player.id === playerId ? { ...player, name } : player\n      )\n    );\n  }, []);\n\n  const toggleShowTable = useCallback(\n    () => setShowTable((showTable) => !showTable),\n    []\n  );\n\n  const handleCanvasClick = useCallback(\n    (event) => {\n      if (!canvas) {\n        return;\n      }\n      const playerPositions = getPlayerPositions(canvas, players);\n      const mousePosition = getCanvasMousePosition(canvas, event);\n      const playerPositionsWithDistance = playerPositions\n        .map((playerPosition) => ({\n          playerPosition,\n          distance: getDistance(playerPosition, mousePosition),\n        }))\n        .sort((a, b) => a.distance - b.distance);\n\n      const [nearest] = playerPositionsWithDistance;\n\n      if (nearest && nearest.distance < 50) {\n        const { player: playerToKill } = nearest.playerPosition;\n\n        setPlayers(\n          players.map((player) =>\n            player.id === playerToKill.id\n              ? { ...player, dead: !player.dead }\n              : player\n          )\n        );\n      }\n    },\n    [canvas, players]\n  );\n\n  const handleExportTableClick = useCallback(() => {\n    if (!canvas) {\n      return;\n    }\n\n    const now = new Date();\n    const filename = `botct-table-${now.getHours()}_${now.getMinutes()}_${now.getSeconds()}.png`;\n    downloadCanvas(canvas, filename);\n  }, [canvas]);\n\n  useEffect(() => {\n    if (!canvas || !canvasContext) {\n      return;\n    }\n    renderTable(canvas, canvasContext, players);\n  }, [canvas, canvasContext, players]);\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      localStorage.setItem(stateKey, JSON.stringify({ players, showTable }));\n    }, 500);\n\n    return () => clearTimeout(timeout);\n  }, [players, showTable]);\n\n  if (showTable) {\n    return (\n      <div className=\"App\">\n        <canvas\n          className=\"TableCanvas\"\n          width={800}\n          height={800}\n          ref={setCanvas}\n          onClick={handleCanvasClick}\n        />\n        <button onClick={handleExportTableClick}>Export</button>\n        <button onClick={toggleShowTable}>Back to Player List</button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"App\">\n      <ul className=\"PlayerList\">\n        {players.map((player) => (\n          <li key={player.id} className=\"PlayerListItem\">\n            <input\n              className=\"PlayerNameInput\"\n              value={player.name}\n              onChange={(event) =>\n                handlePlayerNameChange(player.id, event.currentTarget.value)\n              }\n            />\n            <button\n              className=\"PlayerDeleteButton\"\n              onClick={() => handleRemovePlayer(player.id)}\n            >\n              {\"\\u2715\"}\n            </button>\n          </li>\n        ))}\n      </ul>\n      <button onClick={handleAddPlayer}>Add Player</button>\n      <button onClick={toggleShowTable}>View Table</button>\n    </div>\n  );\n}\n\nfunction renderTable(canvas, context, players) {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, canvas.width, canvas.height);\n  context.fillStyle = \"black\";\n  const tableCircle = getTableCircle(canvas);\n  const playerPositions = getPlayerPositions(canvas, players);\n  const deadXWidth = 25;\n\n  context.beginPath();\n  context.arc(tableCircle.x, tableCircle.y, tableCircle.radius, 0, Math.PI * 2);\n  context.stroke();\n\n  context.font = \"16px Arial\";\n  context.textAlign = \"center\";\n\n  for (const { x, y, player } of playerPositions) {\n    context.fillText(player.name, x, y + 8, 100);\n    context.stroke();\n\n    if (player.dead) {\n      context.beginPath();\n      context.moveTo(x - deadXWidth, y - deadXWidth);\n      context.lineTo(x + deadXWidth, y + deadXWidth);\n      context.stroke();\n\n      context.beginPath();\n      context.moveTo(x - deadXWidth, y + deadXWidth);\n      context.lineTo(x + deadXWidth, y - deadXWidth);\n      context.stroke();\n    }\n  }\n}\n\nfunction getTableCircle(canvas) {\n  const { width, height } = canvas;\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const circleRadius = Math.min(width, height) / 2 - 200;\n\n  return {\n    x: centerX,\n    y: centerY,\n    radius: circleRadius,\n  };\n}\n\nfunction getPlayerPositions(canvas, players) {\n  const tableCircle = getTableCircle(canvas);\n  const playerCount = players.length;\n\n  return players.map((player, i) => ({\n    player,\n    x:\n      tableCircle.x +\n      (tableCircle.radius + 50) * Math.cos(((Math.PI * 2) / playerCount) * i),\n    y:\n      tableCircle.y +\n      (tableCircle.radius + 50) * Math.sin(((Math.PI * 2) / playerCount) * i),\n  }));\n}\n\nfunction getCanvasMousePosition(canvas, event) {\n  const { left, top, width, height } = canvas.getBoundingClientRect();\n  const scaleX = canvas.width / width;\n  const scaleY = canvas.height / height;\n\n  return {\n    x: (event.clientX - left) * scaleX,\n    y: (event.clientY - top) * scaleY,\n  };\n}\n\nfunction getDistance(a, b) {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction downloadCanvas(canvas, fileName) {\n  const link = document.createElement(\"a\");\n  link.setAttribute(\"download\", fileName);\n  link.setAttribute(\n    \"href\",\n    canvas.toDataURL(\"image/png\").replace(\"image/png\", \"image/octet-stream\")\n  );\n  link.click();\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}